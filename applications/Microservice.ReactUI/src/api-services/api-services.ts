//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as moment from 'moment';

export class MovieAPIService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMovie(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<MovieDto> {
        let url_ = this.baseUrl + "/api/MS/Movie/GetMovie?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMovie(_response);
        });
    }

    protected processGetMovie(response: AxiosResponse): Promise<MovieDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MovieDto.fromJS(resultData200);
            return Promise.resolve<MovieDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MovieDto>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getMovies(pageIndex: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<MovieListDto> {
        let url_ = this.baseUrl + "/api/MS/Movie/GetMovies?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMovies(_response);
        });
    }

    protected processGetMovies(response: AxiosResponse): Promise<MovieListDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MovieListDto.fromJS(resultData200);
            return Promise.resolve<MovieListDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MovieListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMovie(body: CreateMovieDto | undefined , cancelToken?: CancelToken | undefined): Promise<MovieDto> {
        let url_ = this.baseUrl + "/api/MS/Movie/CreateMovie";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMovie(_response);
        });
    }

    protected processCreateMovie(response: AxiosResponse): Promise<MovieDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MovieDto.fromJS(resultData200);
            return Promise.resolve<MovieDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MovieDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateMovie(id: string | undefined, body: UpdateMovieDto | undefined , cancelToken?: CancelToken | undefined): Promise<MovieDto> {
        let url_ = this.baseUrl + "/api/MS/Movie/UpdateMovie?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMovie(_response);
        });
    }

    protected processUpdateMovie(response: AxiosResponse): Promise<MovieDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MovieDto.fromJS(resultData200);
            return Promise.resolve<MovieDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MovieDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMovie(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/MS/Movie/DeleteMovie?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMovie(_response);
        });
    }

    protected processDeleteMovie(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMovieReviews(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<ReviewDto[]> {
        let url_ = this.baseUrl + "/api/RS/Movie/GetMovieReviews?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMovieReviews(_response);
        });
    }

    protected processGetMovieReviews(response: AxiosResponse): Promise<ReviewDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ReviewDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReviewDto[]>(null as any);
    }
}

export class ReviewAPIService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReview(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<ReviewDto> {
        let url_ = this.baseUrl + "/api/RS/Review/GetReview?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReview(_response);
        });
    }

    protected processGetReview(response: AxiosResponse): Promise<ReviewDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReviewDto.fromJS(resultData200);
            return Promise.resolve<ReviewDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReviewDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReview(body: CreateReviewDto | undefined , cancelToken?: CancelToken | undefined): Promise<ReviewDto> {
        let url_ = this.baseUrl + "/api/RS/Review/CreateReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateReview(_response);
        });
    }

    protected processCreateReview(response: AxiosResponse): Promise<ReviewDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReviewDto.fromJS(resultData200);
            return Promise.resolve<ReviewDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReviewDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMovie(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/RS/Review/DeleteMovie?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMovie(_response);
        });
    }

    protected processDeleteMovie(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TestAPIService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TS/Test/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserAPIService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserReviews(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<ReviewDto[]> {
        let url_ = this.baseUrl + "/api/RS/User/GetUserReviews?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserReviews(_response);
        });
    }

    protected processGetUserReviews(response: AxiosResponse): Promise<ReviewDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ReviewDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReviewDto[]>(null as any);
    }
}

export class AggregateRouteConfig implements IAggregateRouteConfig {
    routeKey!: string | undefined;
    parameter!: string | undefined;
    jsonPath!: string | undefined;

    constructor(data?: IAggregateRouteConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeKey = _data["routeKey"];
            this.parameter = _data["parameter"];
            this.jsonPath = _data["jsonPath"];
        }
    }

    static fromJS(data: any): AggregateRouteConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateRouteConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeKey"] = this.routeKey;
        data["parameter"] = this.parameter;
        data["jsonPath"] = this.jsonPath;
        return data;
    }
}

export interface IAggregateRouteConfig {
    routeKey: string | undefined;
    parameter: string | undefined;
    jsonPath: string | undefined;
}

export class CreateMovieDto implements ICreateMovieDto {
    title!: string;

    constructor(data?: ICreateMovieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateMovieDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateMovieDto {
    title: string;
}

export class CreateReviewDto implements ICreateReviewDto {
    movieId!: string;
    text!: string | undefined;
    rating!: RatingEnum;

    constructor(data?: ICreateReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movieId = _data["movieId"];
            this.text = _data["text"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): CreateReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movieId"] = this.movieId;
        data["text"] = this.text;
        data["rating"] = this.rating;
        return data;
    }
}

export interface ICreateReviewDto {
    movieId: string;
    text: string | undefined;
    rating: RatingEnum;
}

export class FileAggregateRoute implements IFileAggregateRoute {
    routeKeys!: string[] | undefined;
    routeKeysConfig!: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate!: string | undefined;
    upstreamHost!: string | undefined;
    routeIsCaseSensitive!: boolean;
    aggregator!: string | undefined;
    readonly upstreamHttpMethod!: string[] | undefined;
    priority!: number;

    constructor(data?: IFileAggregateRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routeKeys"])) {
                this.routeKeys = [] as any;
                for (let item of _data["routeKeys"])
                    this.routeKeys!.push(item);
            }
            if (Array.isArray(_data["routeKeysConfig"])) {
                this.routeKeysConfig = [] as any;
                for (let item of _data["routeKeysConfig"])
                    this.routeKeysConfig!.push(AggregateRouteConfig.fromJS(item));
            }
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            this.upstreamHost = _data["upstreamHost"];
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.aggregator = _data["aggregator"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                (<any>this).upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    (<any>this).upstreamHttpMethod!.push(item);
            }
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): FileAggregateRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileAggregateRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routeKeys)) {
            data["routeKeys"] = [];
            for (let item of this.routeKeys)
                data["routeKeys"].push(item);
        }
        if (Array.isArray(this.routeKeysConfig)) {
            data["routeKeysConfig"] = [];
            for (let item of this.routeKeysConfig)
                data["routeKeysConfig"].push(item.toJSON());
        }
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        data["upstreamHost"] = this.upstreamHost;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["aggregator"] = this.aggregator;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["priority"] = this.priority;
        return data;
    }
}

export interface IFileAggregateRoute {
    routeKeys: string[] | undefined;
    routeKeysConfig: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate: string | undefined;
    upstreamHost: string | undefined;
    routeIsCaseSensitive: boolean;
    aggregator: string | undefined;
    upstreamHttpMethod: string[] | undefined;
    priority: number;
}

export class FileAuthenticationOptions implements IFileAuthenticationOptions {
    authenticationProviderKey!: string | undefined;
    allowedScopes!: string[] | undefined;

    constructor(data?: IFileAuthenticationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationProviderKey = _data["authenticationProviderKey"];
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
        }
    }

    static fromJS(data: any): FileAuthenticationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileAuthenticationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationProviderKey"] = this.authenticationProviderKey;
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        return data;
    }
}

export interface IFileAuthenticationOptions {
    authenticationProviderKey: string | undefined;
    allowedScopes: string[] | undefined;
}

export class FileCacheOptions implements IFileCacheOptions {
    ttlSeconds!: number;
    region!: string | undefined;

    constructor(data?: IFileCacheOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ttlSeconds = _data["ttlSeconds"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FileCacheOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileCacheOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ttlSeconds"] = this.ttlSeconds;
        data["region"] = this.region;
        return data;
    }
}

export interface IFileCacheOptions {
    ttlSeconds: number;
    region: string | undefined;
}

export class FileConfiguration implements IFileConfiguration {
    routes!: FileRoute[] | undefined;
    dynamicRoutes!: FileDynamicRoute[] | undefined;
    aggregates!: FileAggregateRoute[] | undefined;
    globalConfiguration!: FileGlobalConfiguration;

    constructor(data?: IFileConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(FileRoute.fromJS(item));
            }
            if (Array.isArray(_data["dynamicRoutes"])) {
                this.dynamicRoutes = [] as any;
                for (let item of _data["dynamicRoutes"])
                    this.dynamicRoutes!.push(FileDynamicRoute.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates!.push(FileAggregateRoute.fromJS(item));
            }
            this.globalConfiguration = _data["globalConfiguration"] ? FileGlobalConfiguration.fromJS(_data["globalConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item.toJSON());
        }
        if (Array.isArray(this.dynamicRoutes)) {
            data["dynamicRoutes"] = [];
            for (let item of this.dynamicRoutes)
                data["dynamicRoutes"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["globalConfiguration"] = this.globalConfiguration ? this.globalConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileConfiguration {
    routes: FileRoute[] | undefined;
    dynamicRoutes: FileDynamicRoute[] | undefined;
    aggregates: FileAggregateRoute[] | undefined;
    globalConfiguration: FileGlobalConfiguration;
}

export class FileDynamicRoute implements IFileDynamicRoute {
    serviceName!: string | undefined;
    rateLimitRule!: FileRateLimitRule;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileDynamicRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.rateLimitRule = _data["rateLimitRule"] ? FileRateLimitRule.fromJS(_data["rateLimitRule"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileDynamicRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileDynamicRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["rateLimitRule"] = this.rateLimitRule ? this.rateLimitRule.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileDynamicRoute {
    serviceName: string | undefined;
    rateLimitRule: FileRateLimitRule;
    downstreamHttpVersion: string | undefined;
}

export class FileGlobalConfiguration implements IFileGlobalConfiguration {
    requestIdKey!: string | undefined;
    serviceDiscoveryProvider!: FileServiceDiscoveryProvider;
    rateLimitOptions!: FileRateLimitOptions;
    qoSOptions!: FileQoSOptions;
    baseUrl!: string | undefined;
    loadBalancerOptions!: FileLoadBalancerOptions;
    downstreamScheme!: string | undefined;
    httpHandlerOptions!: FileHttpHandlerOptions;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileGlobalConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestIdKey = _data["requestIdKey"];
            this.serviceDiscoveryProvider = _data["serviceDiscoveryProvider"] ? FileServiceDiscoveryProvider.fromJS(_data["serviceDiscoveryProvider"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitOptions.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.baseUrl = _data["baseUrl"];
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.downstreamScheme = _data["downstreamScheme"];
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileGlobalConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileGlobalConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestIdKey"] = this.requestIdKey;
        data["serviceDiscoveryProvider"] = this.serviceDiscoveryProvider ? this.serviceDiscoveryProvider.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["baseUrl"] = this.baseUrl;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["downstreamScheme"] = this.downstreamScheme;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileGlobalConfiguration {
    requestIdKey: string | undefined;
    serviceDiscoveryProvider: FileServiceDiscoveryProvider;
    rateLimitOptions: FileRateLimitOptions;
    qoSOptions: FileQoSOptions;
    baseUrl: string | undefined;
    loadBalancerOptions: FileLoadBalancerOptions;
    downstreamScheme: string | undefined;
    httpHandlerOptions: FileHttpHandlerOptions;
    downstreamHttpVersion: string | undefined;
}

export class FileHostAndPort implements IFileHostAndPort {
    host!: string | undefined;
    port!: number;

    constructor(data?: IFileHostAndPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): FileHostAndPort {
        data = typeof data === 'object' ? data : {};
        let result = new FileHostAndPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }
}

export interface IFileHostAndPort {
    host: string | undefined;
    port: number;
}

export class FileHttpHandlerOptions implements IFileHttpHandlerOptions {
    allowAutoRedirect!: boolean;
    useCookieContainer!: boolean;
    useTracing!: boolean;
    useProxy!: boolean;
    maxConnectionsPerServer!: number;

    constructor(data?: IFileHttpHandlerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowAutoRedirect = _data["allowAutoRedirect"];
            this.useCookieContainer = _data["useCookieContainer"];
            this.useTracing = _data["useTracing"];
            this.useProxy = _data["useProxy"];
            this.maxConnectionsPerServer = _data["maxConnectionsPerServer"];
        }
    }

    static fromJS(data: any): FileHttpHandlerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileHttpHandlerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowAutoRedirect"] = this.allowAutoRedirect;
        data["useCookieContainer"] = this.useCookieContainer;
        data["useTracing"] = this.useTracing;
        data["useProxy"] = this.useProxy;
        data["maxConnectionsPerServer"] = this.maxConnectionsPerServer;
        return data;
    }
}

export interface IFileHttpHandlerOptions {
    allowAutoRedirect: boolean;
    useCookieContainer: boolean;
    useTracing: boolean;
    useProxy: boolean;
    maxConnectionsPerServer: number;
}

export class FileLoadBalancerOptions implements IFileLoadBalancerOptions {
    type!: string | undefined;
    key!: string | undefined;
    expiry!: number;

    constructor(data?: IFileLoadBalancerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.key = _data["key"];
            this.expiry = _data["expiry"];
        }
    }

    static fromJS(data: any): FileLoadBalancerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileLoadBalancerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["key"] = this.key;
        data["expiry"] = this.expiry;
        return data;
    }
}

export interface IFileLoadBalancerOptions {
    type: string | undefined;
    key: string | undefined;
    expiry: number;
}

export class FileQoSOptions implements IFileQoSOptions {
    exceptionsAllowedBeforeBreaking!: number;
    durationOfBreak!: number;
    timeoutValue!: number;

    constructor(data?: IFileQoSOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exceptionsAllowedBeforeBreaking = _data["exceptionsAllowedBeforeBreaking"];
            this.durationOfBreak = _data["durationOfBreak"];
            this.timeoutValue = _data["timeoutValue"];
        }
    }

    static fromJS(data: any): FileQoSOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileQoSOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionsAllowedBeforeBreaking"] = this.exceptionsAllowedBeforeBreaking;
        data["durationOfBreak"] = this.durationOfBreak;
        data["timeoutValue"] = this.timeoutValue;
        return data;
    }
}

export interface IFileQoSOptions {
    exceptionsAllowedBeforeBreaking: number;
    durationOfBreak: number;
    timeoutValue: number;
}

export class FileRateLimitOptions implements IFileRateLimitOptions {
    clientIdHeader!: string | undefined;
    quotaExceededMessage!: string | undefined;
    rateLimitCounterPrefix!: string | undefined;
    disableRateLimitHeaders!: boolean;
    httpStatusCode!: number;

    constructor(data?: IFileRateLimitOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientIdHeader = _data["clientIdHeader"];
            this.quotaExceededMessage = _data["quotaExceededMessage"];
            this.rateLimitCounterPrefix = _data["rateLimitCounterPrefix"];
            this.disableRateLimitHeaders = _data["disableRateLimitHeaders"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): FileRateLimitOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientIdHeader"] = this.clientIdHeader;
        data["quotaExceededMessage"] = this.quotaExceededMessage;
        data["rateLimitCounterPrefix"] = this.rateLimitCounterPrefix;
        data["disableRateLimitHeaders"] = this.disableRateLimitHeaders;
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface IFileRateLimitOptions {
    clientIdHeader: string | undefined;
    quotaExceededMessage: string | undefined;
    rateLimitCounterPrefix: string | undefined;
    disableRateLimitHeaders: boolean;
    httpStatusCode: number;
}

export class FileRateLimitRule implements IFileRateLimitRule {
    clientWhitelist!: string[] | undefined;
    enableRateLimiting!: boolean;
    period!: string | undefined;
    periodTimespan!: number;
    limit!: number;

    constructor(data?: IFileRateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientWhitelist"])) {
                this.clientWhitelist = [] as any;
                for (let item of _data["clientWhitelist"])
                    this.clientWhitelist!.push(item);
            }
            this.enableRateLimiting = _data["enableRateLimiting"];
            this.period = _data["period"];
            this.periodTimespan = _data["periodTimespan"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): FileRateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientWhitelist)) {
            data["clientWhitelist"] = [];
            for (let item of this.clientWhitelist)
                data["clientWhitelist"].push(item);
        }
        data["enableRateLimiting"] = this.enableRateLimiting;
        data["period"] = this.period;
        data["periodTimespan"] = this.periodTimespan;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IFileRateLimitRule {
    clientWhitelist: string[] | undefined;
    enableRateLimiting: boolean;
    period: string | undefined;
    periodTimespan: number;
    limit: number;
}

export class FileRoute implements IFileRoute {
    downstreamPathTemplate!: string | undefined;
    upstreamPathTemplate!: string | undefined;
    upstreamHttpMethod!: string[] | undefined;
    downstreamHttpMethod!: string | undefined;
    addHeadersToRequest!: { [key: string]: string; } | undefined;
    upstreamHeaderTransform!: { [key: string]: string; } | undefined;
    downstreamHeaderTransform!: { [key: string]: string; } | undefined;
    addClaimsToRequest!: { [key: string]: string; } | undefined;
    routeClaimsRequirement!: { [key: string]: string; } | undefined;
    addQueriesToRequest!: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate!: { [key: string]: string; } | undefined;
    requestIdKey!: string | undefined;
    fileCacheOptions!: FileCacheOptions;
    routeIsCaseSensitive!: boolean;
    serviceName!: string | undefined;
    serviceNamespace!: string | undefined;
    downstreamScheme!: string | undefined;
    qoSOptions!: FileQoSOptions;
    loadBalancerOptions!: FileLoadBalancerOptions;
    rateLimitOptions!: FileRateLimitRule;
    authenticationOptions!: FileAuthenticationOptions;
    httpHandlerOptions!: FileHttpHandlerOptions;
    downstreamHostAndPorts!: FileHostAndPort[] | undefined;
    upstreamHost!: string | undefined;
    key!: string | undefined;
    delegatingHandlers!: string[] | undefined;
    priority!: number;
    timeout!: number;
    dangerousAcceptAnyServerCertificateValidator!: boolean;
    securityOptions!: FileSecurityOptions;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downstreamPathTemplate = _data["downstreamPathTemplate"];
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.downstreamHttpMethod = _data["downstreamHttpMethod"];
            if (_data["addHeadersToRequest"]) {
                this.addHeadersToRequest = {} as any;
                for (let key in _data["addHeadersToRequest"]) {
                    if (_data["addHeadersToRequest"].hasOwnProperty(key))
                        (<any>this.addHeadersToRequest)![key] = _data["addHeadersToRequest"][key];
                }
            }
            if (_data["upstreamHeaderTransform"]) {
                this.upstreamHeaderTransform = {} as any;
                for (let key in _data["upstreamHeaderTransform"]) {
                    if (_data["upstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.upstreamHeaderTransform)![key] = _data["upstreamHeaderTransform"][key];
                }
            }
            if (_data["downstreamHeaderTransform"]) {
                this.downstreamHeaderTransform = {} as any;
                for (let key in _data["downstreamHeaderTransform"]) {
                    if (_data["downstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.downstreamHeaderTransform)![key] = _data["downstreamHeaderTransform"][key];
                }
            }
            if (_data["addClaimsToRequest"]) {
                this.addClaimsToRequest = {} as any;
                for (let key in _data["addClaimsToRequest"]) {
                    if (_data["addClaimsToRequest"].hasOwnProperty(key))
                        (<any>this.addClaimsToRequest)![key] = _data["addClaimsToRequest"][key];
                }
            }
            if (_data["routeClaimsRequirement"]) {
                this.routeClaimsRequirement = {} as any;
                for (let key in _data["routeClaimsRequirement"]) {
                    if (_data["routeClaimsRequirement"].hasOwnProperty(key))
                        (<any>this.routeClaimsRequirement)![key] = _data["routeClaimsRequirement"][key];
                }
            }
            if (_data["addQueriesToRequest"]) {
                this.addQueriesToRequest = {} as any;
                for (let key in _data["addQueriesToRequest"]) {
                    if (_data["addQueriesToRequest"].hasOwnProperty(key))
                        (<any>this.addQueriesToRequest)![key] = _data["addQueriesToRequest"][key];
                }
            }
            if (_data["changeDownstreamPathTemplate"]) {
                this.changeDownstreamPathTemplate = {} as any;
                for (let key in _data["changeDownstreamPathTemplate"]) {
                    if (_data["changeDownstreamPathTemplate"].hasOwnProperty(key))
                        (<any>this.changeDownstreamPathTemplate)![key] = _data["changeDownstreamPathTemplate"][key];
                }
            }
            this.requestIdKey = _data["requestIdKey"];
            this.fileCacheOptions = _data["fileCacheOptions"] ? FileCacheOptions.fromJS(_data["fileCacheOptions"]) : <any>undefined;
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.serviceName = _data["serviceName"];
            this.serviceNamespace = _data["serviceNamespace"];
            this.downstreamScheme = _data["downstreamScheme"];
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitRule.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.authenticationOptions = _data["authenticationOptions"] ? FileAuthenticationOptions.fromJS(_data["authenticationOptions"]) : <any>undefined;
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            if (Array.isArray(_data["downstreamHostAndPorts"])) {
                this.downstreamHostAndPorts = [] as any;
                for (let item of _data["downstreamHostAndPorts"])
                    this.downstreamHostAndPorts!.push(FileHostAndPort.fromJS(item));
            }
            this.upstreamHost = _data["upstreamHost"];
            this.key = _data["key"];
            if (Array.isArray(_data["delegatingHandlers"])) {
                this.delegatingHandlers = [] as any;
                for (let item of _data["delegatingHandlers"])
                    this.delegatingHandlers!.push(item);
            }
            this.priority = _data["priority"];
            this.timeout = _data["timeout"];
            this.dangerousAcceptAnyServerCertificateValidator = _data["dangerousAcceptAnyServerCertificateValidator"];
            this.securityOptions = _data["securityOptions"] ? FileSecurityOptions.fromJS(_data["securityOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downstreamPathTemplate"] = this.downstreamPathTemplate;
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["downstreamHttpMethod"] = this.downstreamHttpMethod;
        if (this.addHeadersToRequest) {
            data["addHeadersToRequest"] = {};
            for (let key in this.addHeadersToRequest) {
                if (this.addHeadersToRequest.hasOwnProperty(key))
                    (<any>data["addHeadersToRequest"])[key] = (<any>this.addHeadersToRequest)[key];
            }
        }
        if (this.upstreamHeaderTransform) {
            data["upstreamHeaderTransform"] = {};
            for (let key in this.upstreamHeaderTransform) {
                if (this.upstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["upstreamHeaderTransform"])[key] = (<any>this.upstreamHeaderTransform)[key];
            }
        }
        if (this.downstreamHeaderTransform) {
            data["downstreamHeaderTransform"] = {};
            for (let key in this.downstreamHeaderTransform) {
                if (this.downstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["downstreamHeaderTransform"])[key] = (<any>this.downstreamHeaderTransform)[key];
            }
        }
        if (this.addClaimsToRequest) {
            data["addClaimsToRequest"] = {};
            for (let key in this.addClaimsToRequest) {
                if (this.addClaimsToRequest.hasOwnProperty(key))
                    (<any>data["addClaimsToRequest"])[key] = (<any>this.addClaimsToRequest)[key];
            }
        }
        if (this.routeClaimsRequirement) {
            data["routeClaimsRequirement"] = {};
            for (let key in this.routeClaimsRequirement) {
                if (this.routeClaimsRequirement.hasOwnProperty(key))
                    (<any>data["routeClaimsRequirement"])[key] = (<any>this.routeClaimsRequirement)[key];
            }
        }
        if (this.addQueriesToRequest) {
            data["addQueriesToRequest"] = {};
            for (let key in this.addQueriesToRequest) {
                if (this.addQueriesToRequest.hasOwnProperty(key))
                    (<any>data["addQueriesToRequest"])[key] = (<any>this.addQueriesToRequest)[key];
            }
        }
        if (this.changeDownstreamPathTemplate) {
            data["changeDownstreamPathTemplate"] = {};
            for (let key in this.changeDownstreamPathTemplate) {
                if (this.changeDownstreamPathTemplate.hasOwnProperty(key))
                    (<any>data["changeDownstreamPathTemplate"])[key] = (<any>this.changeDownstreamPathTemplate)[key];
            }
        }
        data["requestIdKey"] = this.requestIdKey;
        data["fileCacheOptions"] = this.fileCacheOptions ? this.fileCacheOptions.toJSON() : <any>undefined;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["serviceName"] = this.serviceName;
        data["serviceNamespace"] = this.serviceNamespace;
        data["downstreamScheme"] = this.downstreamScheme;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["authenticationOptions"] = this.authenticationOptions ? this.authenticationOptions.toJSON() : <any>undefined;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.downstreamHostAndPorts)) {
            data["downstreamHostAndPorts"] = [];
            for (let item of this.downstreamHostAndPorts)
                data["downstreamHostAndPorts"].push(item.toJSON());
        }
        data["upstreamHost"] = this.upstreamHost;
        data["key"] = this.key;
        if (Array.isArray(this.delegatingHandlers)) {
            data["delegatingHandlers"] = [];
            for (let item of this.delegatingHandlers)
                data["delegatingHandlers"].push(item);
        }
        data["priority"] = this.priority;
        data["timeout"] = this.timeout;
        data["dangerousAcceptAnyServerCertificateValidator"] = this.dangerousAcceptAnyServerCertificateValidator;
        data["securityOptions"] = this.securityOptions ? this.securityOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileRoute {
    downstreamPathTemplate: string | undefined;
    upstreamPathTemplate: string | undefined;
    upstreamHttpMethod: string[] | undefined;
    downstreamHttpMethod: string | undefined;
    addHeadersToRequest: { [key: string]: string; } | undefined;
    upstreamHeaderTransform: { [key: string]: string; } | undefined;
    downstreamHeaderTransform: { [key: string]: string; } | undefined;
    addClaimsToRequest: { [key: string]: string; } | undefined;
    routeClaimsRequirement: { [key: string]: string; } | undefined;
    addQueriesToRequest: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate: { [key: string]: string; } | undefined;
    requestIdKey: string | undefined;
    fileCacheOptions: FileCacheOptions;
    routeIsCaseSensitive: boolean;
    serviceName: string | undefined;
    serviceNamespace: string | undefined;
    downstreamScheme: string | undefined;
    qoSOptions: FileQoSOptions;
    loadBalancerOptions: FileLoadBalancerOptions;
    rateLimitOptions: FileRateLimitRule;
    authenticationOptions: FileAuthenticationOptions;
    httpHandlerOptions: FileHttpHandlerOptions;
    downstreamHostAndPorts: FileHostAndPort[] | undefined;
    upstreamHost: string | undefined;
    key: string | undefined;
    delegatingHandlers: string[] | undefined;
    priority: number;
    timeout: number;
    dangerousAcceptAnyServerCertificateValidator: boolean;
    securityOptions: FileSecurityOptions;
    downstreamHttpVersion: string | undefined;
}

export class FileSecurityOptions implements IFileSecurityOptions {
    ipAllowedList!: string[] | undefined;
    ipBlockedList!: string[] | undefined;

    constructor(data?: IFileSecurityOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ipAllowedList"])) {
                this.ipAllowedList = [] as any;
                for (let item of _data["ipAllowedList"])
                    this.ipAllowedList!.push(item);
            }
            if (Array.isArray(_data["ipBlockedList"])) {
                this.ipBlockedList = [] as any;
                for (let item of _data["ipBlockedList"])
                    this.ipBlockedList!.push(item);
            }
        }
    }

    static fromJS(data: any): FileSecurityOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileSecurityOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ipAllowedList)) {
            data["ipAllowedList"] = [];
            for (let item of this.ipAllowedList)
                data["ipAllowedList"].push(item);
        }
        if (Array.isArray(this.ipBlockedList)) {
            data["ipBlockedList"] = [];
            for (let item of this.ipBlockedList)
                data["ipBlockedList"].push(item);
        }
        return data;
    }
}

export interface IFileSecurityOptions {
    ipAllowedList: string[] | undefined;
    ipBlockedList: string[] | undefined;
}

export class FileServiceDiscoveryProvider implements IFileServiceDiscoveryProvider {
    scheme!: string | undefined;
    host!: string | undefined;
    port!: number;
    type!: string | undefined;
    token!: string | undefined;
    configurationKey!: string | undefined;
    pollingInterval!: number;
    namespace!: string | undefined;

    constructor(data?: IFileServiceDiscoveryProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheme = _data["scheme"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.type = _data["type"];
            this.token = _data["token"];
            this.configurationKey = _data["configurationKey"];
            this.pollingInterval = _data["pollingInterval"];
            this.namespace = _data["namespace"];
        }
    }

    static fromJS(data: any): FileServiceDiscoveryProvider {
        data = typeof data === 'object' ? data : {};
        let result = new FileServiceDiscoveryProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        data["host"] = this.host;
        data["port"] = this.port;
        data["type"] = this.type;
        data["token"] = this.token;
        data["configurationKey"] = this.configurationKey;
        data["pollingInterval"] = this.pollingInterval;
        data["namespace"] = this.namespace;
        return data;
    }
}

export interface IFileServiceDiscoveryProvider {
    scheme: string | undefined;
    host: string | undefined;
    port: number;
    type: string | undefined;
    token: string | undefined;
    configurationKey: string | undefined;
    pollingInterval: number;
    namespace: string | undefined;
}

export class MovieDto implements IMovieDto {
    id!: string;
    title!: string | undefined;

    constructor(data?: IMovieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): MovieDto {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IMovieDto {
    id: string;
    title: string | undefined;
}

export class MovieListDto implements IMovieListDto {
    items!: MovieDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMovieListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MovieDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MovieListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MovieListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IMovieListDto {
    items: MovieDto[] | undefined;
    totalCount: number;
}

export enum RatingEnum {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class ReviewDto implements IReviewDto {
    id!: string;
    userId!: string;
    movieId!: string;
    text!: string | undefined;
    rating!: RatingEnum;

    constructor(data?: IReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.movieId = _data["movieId"];
            this.text = _data["text"];
            this.rating = _data["rating"];
        }
    }

    static fromJS(data: any): ReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["movieId"] = this.movieId;
        data["text"] = this.text;
        data["rating"] = this.rating;
        return data;
    }
}

export interface IReviewDto {
    id: string;
    userId: string;
    movieId: string;
    text: string | undefined;
    rating: RatingEnum;
}

export class UpdateMovieDto implements IUpdateMovieDto {
    title!: string;

    constructor(data?: IUpdateMovieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateMovieDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMovieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateMovieDto {
    title: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}